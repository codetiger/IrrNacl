namespace irr
{
namespace video
{
void COGLES2SLMaterialRenderer::fillAllShaders () {
	COGLES2FixedPipeline_fsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_TEXTURE_UNITS 4 "
								"#define FOG_EXP 1 "
								"#define FOG_LINEAR 2 "
								" "
								"#define TwoD             24 "
								"#define Solid            0 "
								"#define Solid2Layer      1 "
								"#define LightMap         2 "
								"#define DetailMap		 9 "
								"#define SphereMap		 10 "
								"#define Reflection2Layer 11 "
								"#define TransparentAlphaChannel 13 "
								"#define TransparentVertexAlpha 15 "
								" "
								"precision mediump float; "
								" "
								"vec4 red   = vec4(1.0, 0.0, 0.0, 1.0); "
								"vec4 green = vec4(0.0, 1.0, 0.0, 1.0); "
								"vec4 blue  = vec4(0.0, 0.0, 1.0, 1.0); "
								" "
								" "
								"/* Varyings */ "
								" "
								"varying vec4 varTexCoord[MAX_TEXTURE_UNITS]; "
								"varying vec4 varVertexColor; "
								"varying float eyeDist; "
								"varying float varClipDist; "
								" "
								"/* Uniforms */ "
								" "
								"uniform int uRenderMode; "
								" "
								"uniform bool  uAlphaTest; "
								"uniform float uAlphaValue; "
								" "
								"/* Fog Uniforms */ "
								" "
								"uniform bool  uFog; "
								"uniform int   uFogType; "
								"uniform vec4  uFogColor; "
								"uniform float uFogStart; "
								"uniform float uFogEnd; "
								"uniform float uFogDensity; "
								" "
								"/* Texture Uniforms */ "
								" "
								"uniform sampler2D uTextureUnit0; "
								"uniform sampler2D uTextureUnit1; "
								"uniform bool      uUseTexture [MAX_TEXTURE_UNITS]; "
								" "
								"vec4 render2D(void) "
								"{ "
								"	vec4 color = varVertexColor; "
								"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	if(uUseTexture[0]) "
								"	{ "
								"		color *= texel; "
								"	} "
								"	return color; "
								"} "
								" "
								"vec4 renderSolid(void) "
								"{ "
								"	vec4 color = varVertexColor; "
								"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	if(uUseTexture[0]) "
								"		color *= texel; "
								"	return color; "
								"} "
								" "
								"vec4 renderTransparentVertexAlpha(void) "
								"{ "
								"	vec4 color = renderSolid(); "
								"	color.a = varVertexColor.a; "
								"	return color; "
								"} "
								" "
								"vec4 renderTransparentAlphaChannel(void) "
								"{ "
								"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	vec4 color = texel * varVertexColor; "
								"	color.a = texel.a; "
								"	return color; "
								"} "
								" "
								"vec4 render2LayerSolid(void) "
								"{ "
								"	float blendFactor = varVertexColor.a; "
								"	vec4 texel0 = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	vec4 texel1 = texture2D(uTextureUnit1, varTexCoord[1].xy); "
								"	vec4 color = texel0 * blendFactor + texel1 * ( 1.0 - blendFactor ); "
								"	return color; "
								"} "
								" "
								"vec4 renderLightMap(void) "
								"{ "
								"	vec4 texel0  = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	vec4 texel1  = texture2D(uTextureUnit1, varTexCoord[1].xy); "
								"	vec4 color   = texel0 * texel1 * 4.0; "
								"	color.a = texel0.a * texel0.a; "
								"	return color; "
								"} "
								" "
								"vec4 renderDetailMap(void) "
								"{ "
								"	vec4 texel0  = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	vec4 texel1  = texture2D(uTextureUnit1, varTexCoord[1].xy); "
								"	vec4 color   = texel0; "
								"	color += texel1 - 0.5; "
								"	return color; "
								"} "
								" "
								"vec4 renderReflection2Layer(void) "
								"{ "
								"	vec4 color = varVertexColor; "
								"	vec4 texel0 = texture2D(uTextureUnit0, varTexCoord[0].xy); "
								"	vec4 texel1 = texture2D(uTextureUnit1, varTexCoord[1].xy); "
								"	color *=  texel0 * texel1; "
								"	return color; "
								"} "
								" "
								"float ComputeFog() "
								"{ "
								"	float factor = 1.0; "
								"	if(uFogType == FOG_LINEAR) "
								"	{ "
								"		factor = (uFogEnd - eyeDist) / (uFogEnd - uFogStart); "
								"	} "
								"	else if(uFogType == FOG_EXP) "
								"	{ "
								"		 factor = exp(-(eyeDist * uFogDensity)); "
								"	} "
								"	else //uFogType == FOG_EXP2 "
								"	{ "
								"		factor = eyeDist * uFogDensity; "
								"		factor = exp(-(factor * factor)) ; "
								"	} "
								"	factor = clamp(factor, 0.0, 1.0); "
								"	return factor; "
								"} "
								" "
								"void main (void) "
								"{ "
								"	if(varClipDist < 0.0) "
								"		discard; "
								"	 "
								"	if( uRenderMode == TwoD) "
								"		gl_FragColor = render2D(); "
								"	else if( uRenderMode == Solid) "
								"		gl_FragColor = renderSolid(); "
								"	else if(uRenderMode == LightMap) "
								"		gl_FragColor = renderLightMap(); "
								"	else if(uRenderMode == DetailMap) "
								"		gl_FragColor = renderDetailMap(); "
								"	else if(uRenderMode == SphereMap) "
								"		gl_FragColor = renderSolid(); "
								"	else if(uRenderMode == Reflection2Layer) "
								"		gl_FragColor = renderReflection2Layer(); "
								"	else if(uRenderMode == TransparentVertexAlpha) "
								"		gl_FragColor = renderTransparentVertexAlpha(); "
								"	else if(uRenderMode == TransparentAlphaChannel) "
								"		gl_FragColor = renderTransparentAlphaChannel(); "
								"	else "
								"		gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0); "
								"		 "
								"	//gl_FragColor = varVertexColor; "
								" "
								"	if(uFog) "
								"	{ "
								"		float fogFactor = ComputeFog(); "
								"		gl_FragColor = gl_FragColor * fogFactor + uFogColor * (1.0 - fogFactor); "
								"	} "
								"			 "
								"	if(uAlphaTest && uAlphaValue > gl_FragColor.a) "
								"		discard; "
								"	 "
								"} ";


		COGLES2FixedPipeline_vsh =
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_TEXTURE_UNITS 4 "
								"#define MAX_LIGHTS 8 "
								" "
								"#define SphereMap        10 "
								"#define Reflection2Layer 11 "
								" "
								"const vec4 red   = vec4(1.0, 0.0, 0.0, 1.0); "
								"const vec4 green = vec4(0.0, 1.0, 0.0, 1.0); "
								"const vec4 blue  = vec4(0.0, 0.0, 1.0, 1.0); "
								"const vec4 white = vec4(1.0); "
								"const vec4 black = vec4(0.0); "
								" "
								"/* Vertex Attributes */ "
								"  "
								"attribute vec4 inVertexPosition; "
								"attribute vec4 inVertexColor; "
								"attribute vec4 inTexCoord0; "
								"attribute vec4 inTexCoord1; "
								"attribute vec3 inVertexNormal; "
								" "
								"uniform int uRenderMode; "
								" "
								"/* Matrix Uniforms */ "
								" "
								"uniform mat4 uMvpMatrix; "
								"uniform mat4 uWorldMatrix; "
								" "
								"uniform bool uNormalize; "
								"uniform vec3 uEyePos; "
								" "
								"/* Light Uniforms */ "
								" "
								"uniform bool  uUseLight         [MAX_LIGHTS]; "
								"uniform vec4  uLightPosition    [MAX_LIGHTS]; "
								"uniform vec4  uLightAmbient     [MAX_LIGHTS]; "
								"uniform vec4  uLightDiffuse     [MAX_LIGHTS]; "
								"#ifdef USE_SPECULAR "
								"uniform vec4  uLightSpecular    [MAX_LIGHTS]; "
								"#endif "
								"#ifdef USE_LIGHT_CUTOFF "
								"uniform vec3  uLightDirection   [MAX_LIGHTS]; "
								"uniform float uLightCutoff      [MAX_LIGHTS]; "
								"uniform float uLightExponent    [MAX_LIGHTS]; "
								"#endif "
								"uniform vec3  uLightAttenuation [MAX_LIGHTS]; "
								"uniform vec4  uAmbientColor; "
								"uniform bool  uLighting; "
								" "
								"/* Material Uniforms */ "
								"uniform vec4  uMaterialAmbient; "
								"uniform vec4  uMaterialEmission; "
								"uniform vec4  uMaterialDiffuse; "
								"uniform vec4  uMaterialSpecular; "
								"uniform float uMaterialShininess; "
								"uniform int   uColorMaterial; "
								" "
								"#define ECM_NONE     0 "
								"#define ECM_DIFFUSE  1 "
								"#define ECM_AMBIENT  2 "
								"#define ECM_EMISSIVE 3 "
								"#define ECM_SPECULAR 4 "
								"#define ECM_DIFFUSE_AND_AMBIENT 5 "
								" "
								"/* Texture Uniforms */ "
								"uniform bool uUseTexture    [MAX_TEXTURE_UNITS]; "
								"uniform mat4 uTextureMatrix [MAX_TEXTURE_UNITS]; "
								"uniform bool uUseTexMatrix  [MAX_TEXTURE_UNITS]; "
								" "
								"/* Clip Plane Uniforms */ "
								"uniform bool uClip; "
								"uniform vec4 uClipPlane; "
								"varying float varClipDist; "
								" "
								"/* Varyings */ "
								" "
								"varying vec4 varTexCoord[MAX_TEXTURE_UNITS]; "
								"varying vec4 varVertexColor; "
								"varying float eyeDist; "
								" "
								"/* shader variables */ "
								" "
								"vec3 gNormal; "
								"vec3 gWorldPos; "
								"vec4 gColor; "
								" "
								"struct material { "
								"   vec4    Ambient; "
								"   vec4    Diffuse; "
								"   vec4    Specular; "
								"   vec4    Emission; "
								"   float   Shininess; "
								"} ; "
								" "
								"material gMaterial; "
								" "
								"vec4 lightEquation(int lidx) "
								"{		 "
								"	vec4 color = vec4(0.0); "
								"	 "
								"	float att = 1.0; "
								"	vec3 lightDir; "
								"	 "
								"	 "
								"	if( uLightPosition[lidx].w == 0.0) // Directional light "
								"	{ "
								"		lightDir = -uLightPosition[lidx].xyz; "
								"	} "
								"	else "
								"	{ "
								"		lightDir = uLightPosition[lidx].xyz - inVertexPosition.xyz; "
								"		att = 1.0 / (uLightAttenuation[lidx].y * length(lightDir)); "
								"		lightDir = normalize(lightDir); "
								"		 "
								"#ifdef USE_LIGHT_CUTOFF "
								"		if(uLightCutoff[lidx] < 180.0) "
								"		{ "
								"			// compute spot factor "
								"			float spotEffect = dot(-lightDir, uLightDirection[lidx]); "
								"			if( spotEffect >= cos( radians( uLightCutoff[lidx]))) "
								"				spotEffect = pow( spotEffect, uLightExponent[lidx]); "
								"			else "
								"				spotEffect = 0.0; "
								"			att *= spotEffect; "
								"		} "
								"#endif "
								"	} "
								"	 "
								"	if(att >= 0.0 ) "
								"	{ "
								"		color += uLightAmbient[lidx] * gMaterial.Ambient; "
								"		 "
								"		//Compute cos(Light, Normal) "
								"		float NdotL = max(dot(normalize(gNormal), lightDir), 0.0); "
								"		color += NdotL * uLightDiffuse[lidx] * gMaterial.Diffuse; "
								"		 "
								"		//Compute cos(hvec, Normal) "
								"#ifdef USE_SPECULAR "
								"		vec3 hvec = normalize(lightDir + vec3(0.0, 0.0, 1.0)); "
								"		float NdotH = dot(gNormal, hvec); "
								"		if(NdotH > 0.0) "
								"		{ "
								"			color += pow(NdotH, uMaterialShininess) * uLightSpecular[lidx] * gMaterial.Specular; "
								"		} "
								"#endif "
								"		color *= att; "
								"	} "
								"	return color; "
								"} "
								" "
								"vec4 computeLighting(void) "
								"{ "
								"	vec4 color = gMaterial.Emission + gMaterial.Ambient * uAmbientColor; "
								" "
								"	for ( int i = 0 ; i < MAX_LIGHTS; ++i) "
								"	{ "
								"		if ( uUseLight[i] ) "
								"		{ "
								"			color += lightEquation(i) ; "
								"		} "
								"	} "
								"	color.a = gMaterial.Diffuse.a; "
								"	return color; "
								"} "
								" "
								"void ReplaceColorMaterial(void) "
								"{ "
								"	gMaterial.Ambient = uMaterialAmbient; "
								"	gMaterial.Diffuse = uMaterialDiffuse; "
								"	gMaterial.Emission = uMaterialEmission; "
								"	gMaterial.Specular = uMaterialSpecular; "
								"	gMaterial.Shininess = uMaterialShininess; "
								" "
								"	if(uColorMaterial == ECM_DIFFUSE) "
								"		gMaterial.Diffuse = gColor; "
								"	else if(uColorMaterial == ECM_AMBIENT) "
								"		gMaterial.Ambient = gColor; "
								"	else if(uColorMaterial == ECM_DIFFUSE_AND_AMBIENT) "
								"	{ "
								"		gMaterial.Diffuse = gColor; "
								"		gMaterial.Ambient = gColor; "
								"	}	 "
								"	else if(uColorMaterial == ECM_EMISSIVE) "
								"		gMaterial.Emission = gColor; "
								"	else if(uColorMaterial == ECM_SPECULAR) "
								"		gMaterial.Specular = gColor; "
								"} "
								" "
								"void main(void) "
								"{ "
								"	gl_Position = uMvpMatrix * inVertexPosition; "
								"	 "
								"	gWorldPos = (uWorldMatrix * inVertexPosition).xyz; "
								"	 "
								"	gColor = inVertexColor.bgra; "
								"	 "
								"	gNormal = inVertexNormal.xyz; "
								"	if(uNormalize) "
								"		gNormal = normalize(gNormal); "
								"	 "
								"	ReplaceColorMaterial(); "
								"	if(uLighting) "
								"		varVertexColor = computeLighting(); "
								"	else "
								"		varVertexColor = gColor; "
								"	 "
								"	for(int i = 0; i < MAX_TEXTURE_UNITS; ++i) "
								"		varTexCoord[i] = vec4(0.0); "
								"	 "
								"	if( uUseTexture[0]) "
								"	{ "
								"		if(uRenderMode == SphereMap || uRenderMode == Reflection2Layer) "
								"		{ "
								"			vec3 eyeDir = normalize(inVertexPosition.xyz - uEyePos); "
								"			vec3 reflection = reflect(eyeDir, gNormal); "
								"			float m = 2.0 * sqrt(reflection.x * reflection.x + "
								"								 reflection.y * reflection.y + "
								"								 (reflection.z + 1.0) * (reflection.z + 1.0)); "
								"			varTexCoord[0] = vec4((reflection.x / m + 0.5), (reflection.y / m + 0.5), 0.0, 0.0);  "
								"		} "
								"		else "
								"		{ "
								"			varTexCoord[0] = inTexCoord0; "
								"			if(uUseTexMatrix[0]) "
								"				varTexCoord[0] *= uTextureMatrix[0]; "
								"		} "
								"	} "
								"	if(uUseTexture[1]) "
								"	{ "
								"		varTexCoord[1] = inTexCoord1; "
								"		if(uUseTexMatrix[1]) "
								"			varTexCoord[1] *= uTextureMatrix[1]; "
								"	} "
								"	 "
								"	eyeDist = length(uEyePos); "
								"	 "
								"	varClipDist = uClip ? dot(gWorldPos, uClipPlane.xyz)-uClipPlane.w : 0.0; "
								"	 "
								"	varVertexColor.rgb  = clamp(varVertexColor.rgb, 0.0, 1.0); "
								"	varVertexColor.a = gColor.a; "
								"} ";
								
		COGLES2NormalMap_fsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_LIGHTS 2 "
								" "
								"precision mediump float; "
								" "
								"uniform sampler2D texture0; "
								"uniform sampler2D texture1; "
								" "
								"varying vec4 varTexCoord; "
								"varying vec3 varLightVector[MAX_LIGHTS]; "
								"varying vec4 varLightColor[MAX_LIGHTS]; "
								" "
								"varying vec4 debug; "
								" "
								"void main(void) "
								"{ "
								"	// fetch color and normal map "
								"	vec4 normalMap = texture2D(texture1, varTexCoord.xy) *  2.0 - 1.0; "
								"	vec4 colorMap  = texture2D(texture0, varTexCoord.xy); "
								"	 "
								"	// calculate color of light 0 "
								"	vec4 color = clamp(varLightColor[0], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[0].xyz)); "
								"	 "
								"	// calculate color of light 1 "
								"	color += clamp(varLightColor[1], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[1].xyz)); "
								" "
								"	//luminance * base color "
								"	color *= colorMap; "
								"	color.a = varLightColor[0].a; "
								"	 "
								"	gl_FragColor = color; "
								"}";

		COGLES2NormalMap_vsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_LIGHTS 2 "
								" "
								"attribute vec4 inVertexPosition; "
								"attribute vec4 inVertexColor; "
								"attribute vec4 inTexCoord0; "
								"attribute vec3 inVertexNormal; "
								"attribute vec3 inVertexTangent; "
								"attribute vec3 inVertexBinormal; "
								" "
								"uniform mat4 uMvpMatrix; "
								"uniform vec4 uLightPos[MAX_LIGHTS]; "
								"uniform vec4 uLightColor[MAX_LIGHTS]; "
								" "
								"varying vec4 varTexCoord; "
								"varying vec3 varLightVector[MAX_LIGHTS]; "
								"varying vec4 varLightColor[MAX_LIGHTS]; "
								" "
								"varying vec4 debug; "
								" "
								"void main(void) "
								"{ "
								"	debug = vec4(inVertexNormal, 1.0); "
								"	// transform position to clip space "
								"	gl_Position = uMvpMatrix * inVertexPosition; "
								"	 "
								"	// vertex - lightpositions "
								"	vec4 tempLightVector0 = uLightPos[0] - inVertexPosition; "
								"	vec4 tempLightVector1 = uLightPos[1] - inVertexPosition; "
								"	 "
								"	// transform the light vector 1 with U, V, W "
								"	varLightVector[0].x = dot(inVertexTangent,  tempLightVector0.xyz); "
								"	varLightVector[0].y = dot(inVertexBinormal, tempLightVector0.xyz); "
								"	varLightVector[0].z = dot(inVertexNormal,   tempLightVector0.xyz); "
								" "
								"	 "
								"	// transform the light vector 2 with U, V, W "
								"	varLightVector[1].x = dot(inVertexTangent,  tempLightVector1.xyz); "
								"	varLightVector[1].y = dot(inVertexBinormal, tempLightVector1.xyz); "
								"	varLightVector[1].z = dot(inVertexNormal,   tempLightVector1.xyz); "
								" "
								"	// calculate attenuation of light 0 "
								"	varLightColor[0].w = 0.0; "
								"	varLightColor[0].x = dot(tempLightVector0, tempLightVector0); "
								"	varLightColor[0].x *= uLightColor[0].w; "
								"	varLightColor[0] = vec4(inversesqrt(varLightColor[0].x)); "
								"	varLightColor[0] *= uLightColor[0]; "
								"	 "
								"	// normalize light vector 0 "
								"	varLightVector[0] = normalize(varLightVector[0]); "
								"	 "
								"	// calculate attenuation of light 1 "
								"	varLightColor[1].w = 0.0; "
								"	varLightColor[1].x = dot(tempLightVector1, tempLightVector1); "
								"	varLightColor[1].x *= uLightColor[1].w; "
								"	varLightColor[1] = vec4(inversesqrt(varLightColor[1].x)); "
								"	varLightColor[1] *= uLightColor[1]; "
								"	 "
								"	// normalize light vector 1 "
								"	varLightVector[1] = normalize(varLightVector[1]); "
								"	 "
								"	// move out texture coordinates and original alpha value "
								"	varTexCoord = inTexCoord0; "
								"	varLightColor[0].a = inVertexColor.a; "
								"}";

		COGLES2ParallaxMap_fsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_LIGHTS 2 "
								" "
								"precision mediump float; "
								" "
								"uniform sampler2D texture0; "
								"uniform sampler2D texture1; "
								" "
								"//uniform vec4 uLightDiffuse[MAX_LIGHTS]; "
								"uniform float uHeightScale; "
								" "
								"varying vec4 varTexCoord; "
								"varying vec3 varLightVector[MAX_LIGHTS]; "
								"varying vec4 varLightColor[MAX_LIGHTS]; "
								"varying vec3 varEyeVector; "
								" "
								"varying vec4 debug; "
								" "
								"void main(void) "
								"{ "
								"	// fetch color and normal map "
								"	vec4 normalMap = texture2D(texture1, varTexCoord.xy) *  2.0 - 1.0; "
								" "
								"	// height = height * scale "
								"	normalMap *= uHeightScale; "
								"	 "
								"	// calculate new texture coord: height * eye + oldTexCoord "
								"	vec2 offset = varEyeVector.xy * normalMap.w + varTexCoord.xy; "
								" "
								"	// fetch new textures "
								"	vec4 colorMap  = texture2D(texture0, offset); "
								"	normalMap = normalize(texture2D(texture1, offset) * 2.0 - 1.0);  "
								"	 "
								"	// calculate color of light 0 "
								"	vec4 color = clamp(varLightColor[0], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[0].xyz)); "
								"	 "
								"	// calculate color of light 1 "
								"	color += clamp(varLightColor[1], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[1].xyz)); "
								" "
								"	//luminance * base color "
								"	color *= colorMap; "
								"	color.a = varLightColor[0].a; "
								"	 "
								"	gl_FragColor = color; "
								"} ";


		COGLES2ParallaxMap_vsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"#define MAX_LIGHTS 2 "
								" "
								"attribute vec4 inVertexPosition; "
								"attribute vec4 inVertexColor; "
								"attribute vec4 inTexCoord0; "
								"attribute vec3 inVertexNormal; "
								"attribute vec3 inVertexTangent; "
								"attribute vec3 inVertexBinormal; "
								" "
								"uniform mat4 uMvpMatrix; "
								"uniform vec4 uLightPos[MAX_LIGHTS]; "
								"uniform vec4 uLightColor[MAX_LIGHTS]; "
								"uniform vec3 uEyePos; "
								" "
								"varying vec4 varTexCoord; "
								"varying vec3 varLightVector[MAX_LIGHTS]; "
								"varying vec4 varLightColor[MAX_LIGHTS]; "
								"varying vec3 varEyeVector; "
								" "
								"varying vec4 debug; "
								" "
								"void main(void) "
								"{ "
								"	debug = vec4(inVertexNormal, 1.0); "
								"	// transform position to clip space "
								"	gl_Position = uMvpMatrix * inVertexPosition; "
								"	 "
								"	// vertex - lightpositions "
								"	vec4 tempLightVector0 = uLightPos[0] - inVertexPosition; "
								"	vec4 tempLightVector1 = uLightPos[1] - inVertexPosition; "
								"	 "
								"	// eye vector "
								"	vec4 Temp = vec4(uEyePos, 1.0) - inVertexPosition; "
								"	 "
								"	// transform the light vector 1 with U, V, W "
								"	varLightVector[0].x = dot(inVertexTangent,  tempLightVector0.xyz); "
								"	varLightVector[0].y = dot(inVertexBinormal, tempLightVector0.xyz); "
								"	varLightVector[0].z = dot(inVertexNormal,   tempLightVector0.xyz); "
								" "
								"	 "
								"	// transform the light vector 2 with U, V, W "
								"	varLightVector[1].x = dot(inVertexTangent,  tempLightVector1.xyz); "
								"	varLightVector[1].y = dot(inVertexBinormal, tempLightVector1.xyz); "
								"	varLightVector[1].z = dot(inVertexNormal,   tempLightVector1.xyz); "
								"	 "
								"	// transform the eye vector with U, V, W  "
								"	varEyeVector.x = dot(inVertexTangent,  Temp.xyz); "
								"	varEyeVector.y = dot(inVertexBinormal, Temp.xyz); "
								"	varEyeVector.z = dot(inVertexNormal,   Temp.xyz); "
								"	varEyeVector *= vec3(1.0,-1.0, -1.0); "
								"	varEyeVector = normalize(varEyeVector); "
								" "
								"	// calculate attenuation of light 0 "
								"	varLightColor[0].w = 0.0; "
								"	varLightColor[0].x = dot(tempLightVector0, tempLightVector0); "
								"	varLightColor[0].x *= uLightColor[0].w; "
								"	varLightColor[0] = vec4(inversesqrt(varLightColor[0].x)); "
								"	varLightColor[0] *= uLightColor[0]; "
								"	 "
								"	// normalize light vector 0 "
								"	varLightVector[0] = normalize(varLightVector[0]); "
								"	 "
								"	// calculate attenuation of light 1 "
								"	varLightColor[1].w = 0.0; "
								"	varLightColor[1].x = dot(tempLightVector1, tempLightVector1); "
								"	varLightColor[1].x *= uLightColor[1].w; "
								"	varLightColor[1] = vec4(inversesqrt(varLightColor[1].x)); "
								"	varLightColor[1] *= uLightColor[1]; "
								"	 "
								"	// normalize light vector 1 "
								"	varLightVector[1] = normalize(varLightVector[1]); "
								"	 "
								"	// move out texture coordinates and original alpha value "
								"	varTexCoord = inTexCoord0; "
								"	varLightColor[0].a = inVertexColor.a; "
								"}";

		COGLES2Renderer2D_fsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"precision mediump float; "
								" "
								"uniform bool uUseTexture; "
								"uniform sampler2D uTextureUnit; "
								"uniform bool uAlphaTest; "
								"uniform float uAlphaValue; "
								" "
								"varying vec4 varVertexColor; "
								"varying vec4 varTexCoord; "
								" "
								"void main(void) "
								"{ "
								"	vec4 color = varVertexColor; "
								"	vec4 texel = texture2D(uTextureUnit, varTexCoord.xy); "
								"	if(uUseTexture) "
								"	{ "
								"		color *= texel; "
								"	} "
								"	 "
								"	if(uAlphaTest && !(color.a > uAlphaValue)) "
								"		discard; "
								"	 "
								"	gl_FragColor = color; "
								"} ";

		COGLES2Renderer2D_vsh = 
								"// Copyright (C) 2009-2010 Amundis "
								"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
								"// and OpenGL ES driver implemented by Christian Stehno "
								"// This file is part of the \"Irrlicht Engine\". "
								"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
								"attribute vec4 inVertexPosition; "
								"attribute vec4 inVertexColor; "
								"attribute vec4 inTexCoord0; "
								" "
								"uniform mat4 uOrthoMatrix; "
								" "
								"varying vec4 varVertexColor; "
								"varying vec4 varTexCoord; "
								" "
								"void main(void) "
								"{ "
								"	gl_Position    = uOrthoMatrix * inVertexPosition; "
								"	varVertexColor = inVertexColor.bgra; "
								"	varTexCoord    = inTexCoord0; "
								"} ";
}
}
}