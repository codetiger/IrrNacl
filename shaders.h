namespace irr
{
namespace video
{
void COGLES2SLMaterialRenderer::fillAllShaders() {
COGLES2FixedPipeline.fsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_TEXTURE_UNITS 4 "
					"#define FOG_EXP 1 "
					"#define FOG_LINEAR 2 "
					" "
					"#define TwoD             24 "
					"#define Solid            0 "
					"#define Solid2Layer      1 "
					"#define LightMap         2 "
					"#define DetailMap		 9 "
					"#define SphereMap		 10 "
					"#define Reflection2Layer 11 "
					"#define TransparentAlphaChannel 13 "
					"#define TransparentVertexAlpha 15 "
					" "
					"precision mediump float; "
					" "
					"vec4 red   = vec4(1.0, 0.0, 0.0, 1.0); "
					"vec4 green = vec4(0.0, 1.0, 0.0, 1.0); "
					"vec4 blue  = vec4(0.0, 0.0, 1.0, 1.0); "
					" "
					" "
					"/* Varyings */ "
					" "
					"varying vec4 varTexCoord[MAX_TEXTURE_UNITS]; "
					"varying vec4 varVertexColor; "
					"varying float eyeDist; "
					"varying float varClipDist; "
					" "
					"/* Uniforms */ "
					" "
					"uniform lowp int uRenderMode; "
					" "
					"uniform bool  uAlphaTest; "
					"uniform float uAlphaValue; "
					" "
					"/* Fog Uniforms */ "
					" "
					"uniform bool  uFog; "
					"uniform int   uFogType; "
					"uniform vec4  uFogColor; "
					"uniform float uFogStart; "
					"uniform float uFogEnd; "
					"uniform float uFogDensity; "
					" "
					"/* Texture Uniforms */ "
					" "
					"uniform sampler2D uTextureUnit0; "
					"uniform sampler2D uTextureUnit1; "
					"uniform bool      uUseTexture [MAX_TEXTURE_UNITS]; "
					" "
					"vec4 render2D(void) "
					"{ "
					"	vec4 color = varVertexColor; "
					"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	//if(uUseTexture[0]) "
					"	{ "
					"		color *= texel; "
					"	} "
					"	return color; "
					"} "
					" "
					"vec4 renderSolid(void) "
					"{ "
					"	vec4 color = varVertexColor; "
					"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	//if(uUseTexture[0]) "
					"		color *= texel; "
					"	return color; "
					"} "
					" "
					"vec4 renderTransparentVertexAlpha(void) "
					"{ "
					"	vec4 color = renderSolid(); "
					"	color.a = varVertexColor.a; "
					"	return color; "
					"} "
					" "
					"vec4 renderTransparentAlphaChannel(void) "
					"{ "
					"	vec4 texel = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	vec4 color = texel * varVertexColor; "
					"	color.a = texel.a; "
					"	return color; "
					"} "
					" "
					"vec4 render2LayerSolid(void) "
					"{ "
					"	float blendFactor = varVertexColor.a; "
					"	vec4 texel0 = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	vec4 texel1 = texture2D(uTextureUnit1, varTexCoord[1].xy); "
					"	vec4 color = texel0 * blendFactor + texel1 * ( 1.0 - blendFactor ); "
					"	return color; "
					"} "
					" "
					"vec4 renderLightMap(void) "
					"{ "
					"	vec4 texel0  = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	vec4 texel1  = texture2D(uTextureUnit1, varTexCoord[1].xy); "
					"	vec4 color   = texel0 * texel1 * 4.0; "
					"	color.a = texel0.a * texel0.a; "
					"	return color; "
					"} "
					" "
					"vec4 renderDetailMap(void) "
					"{ "
					"	vec4 texel0  = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	vec4 texel1  = texture2D(uTextureUnit1, varTexCoord[1].xy); "
					"	vec4 color   = texel0; "
					"	color += texel1 - 0.5; "
					"	return color; "
					"} "
					" "
					"vec4 renderReflection2Layer(void) "
					"{ "
					"	vec4 color = varVertexColor; "
					"	vec4 texel0 = texture2D(uTextureUnit0, varTexCoord[0].xy); "
					"	vec4 texel1 = texture2D(uTextureUnit1, varTexCoord[1].xy); "
					"	color *=  texel0 * texel1; "
					"	return color; "
					"} "
					" "
					"float ComputeFog() "
					"{ "
					"	float factor = 1.0; "
					"	if(uFogType == FOG_LINEAR) "
					"	{ "
					"		factor = (uFogEnd - eyeDist) / (uFogEnd - uFogStart); "
					"	} "
					"	else if(uFogType == FOG_EXP) "
					"	{ "
					"		 factor = exp(-(eyeDist * uFogDensity)); "
					"	} "
					"	else //uFogType == FOG_EXP2 "
					"	{ "
					"		factor = eyeDist * uFogDensity; "
					"		factor = exp(-(factor * factor)) ; "
					"	} "
					"	factor = clamp(factor, 0.0, 1.0); "
					"	return factor; "
					"} "
					" "
					"void main (void) "
					"{ "
					"	if(varClipDist < 0.0) "
					"		discard; "
					"	 "
					"	if( uRenderMode == TwoD) "
					"		gl_FragColor = render2D(); "
					"	else if( uRenderMode == Solid) "
					"		gl_FragColor = renderSolid(); "
					"	else if(uRenderMode == LightMap) "
					"		gl_FragColor = renderLightMap(); "
					"	else if(uRenderMode == DetailMap) "
					"		gl_FragColor = renderDetailMap(); "
					"	else if(uRenderMode == SphereMap) "
					"		gl_FragColor = renderSolid(); "
					"	else if(uRenderMode == Reflection2Layer) "
					"		gl_FragColor = renderReflection2Layer(); "
					"	else if(uRenderMode == TransparentVertexAlpha) "
					"		gl_FragColor = renderTransparentVertexAlpha(); "
					"	else if(uRenderMode == TransparentAlphaChannel) "
					"		gl_FragColor = renderTransparentAlphaChannel(); "
					"	else "
					"		gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0); "
					"		 "
					"	//gl_FragColor = varVertexColor; "
					" "
					"	if(uFog) "
					"	{ "
					"		float fogFactor = ComputeFog(); "
					"		gl_FragColor = gl_FragColor * fogFactor + uFogColor * (1.0 - fogFactor); "
					"	} "
					"			 "
					"	if(uAlphaTest && uAlphaValue > gl_FragColor.a) "
					"		discard; "
					"	 "
					"} ";
COGLES2FixedPipeline.vsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_TEXTURE_UNITS 4 "
					"#define MAX_LIGHTS 8 "
					" "
					"#define SphereMap        10 "
					"#define Reflection2Layer 11 "
					" "
					"const vec4 red   = vec4(1.0, 0.0, 0.0, 1.0); "
					"const vec4 green = vec4(0.0, 1.0, 0.0, 1.0); "
					"const vec4 blue  = vec4(0.0, 0.0, 1.0, 1.0); "
					"const vec4 white = vec4(1.0); "
					"const vec4 black = vec4(0.0); "
					" "
					"/* Vertex Attributes */ "
					"  "
					"attribute vec4 inVertexPosition; "
					"attribute vec4 inVertexColor; "
					"attribute vec4 inTexCoord0; "
					"attribute vec4 inTexCoord1; "
					"attribute vec3 inVertexNormal; "
					" "
					"uniform lowp int uRenderMode; "
					" "
					"/* Matrix Uniforms */ "
					" "
					"uniform mat4 uMvpMatrix; "
					"uniform mat4 uWorldMatrix; "
					" "
					"uniform bool uNormalize; "
					"uniform vec3 uEyePos; "
					" "
					"/* Light Uniforms */ "
					" "
					"uniform bool  uUseLight         [MAX_LIGHTS]; "
					"uniform vec4  uLightPosition    [MAX_LIGHTS]; "
					"uniform vec4  uLightAmbient     [MAX_LIGHTS]; "
					"uniform vec4  uLightDiffuse     [MAX_LIGHTS]; "
					"#ifdef USE_SPECULAR "
					"uniform vec4  uLightSpecular    [MAX_LIGHTS]; "
					"#endif "
					"#ifdef USE_LIGHT_CUTOFF "
					"uniform vec3  uLightDirection   [MAX_LIGHTS]; "
					"uniform float uLightCutoff      [MAX_LIGHTS]; "
					"uniform float uLightExponent    [MAX_LIGHTS]; "
					"#endif "
					"uniform vec3  uLightAttenuation [MAX_LIGHTS]; "
					"uniform vec4  uAmbientColor; "
					"uniform bool  uLighting; "
					" "
					"/* Material Uniforms */ "
					"uniform vec4  uMaterialAmbient; "
					"uniform vec4  uMaterialEmission; "
					"uniform vec4  uMaterialDiffuse; "
					"uniform vec4  uMaterialSpecular; "
					"uniform float uMaterialShininess; "
					"uniform int   uColorMaterial; "
					" "
					"#define ECM_NONE     0 "
					"#define ECM_DIFFUSE  1 "
					"#define ECM_AMBIENT  2 "
					"#define ECM_EMISSIVE 3 "
					"#define ECM_SPECULAR 4 "
					"#define ECM_DIFFUSE_AND_AMBIENT 5 "
					" "
					"/* Texture Uniforms */ "
					"uniform bool uUseTexture    [MAX_TEXTURE_UNITS]; "
					"uniform mat4 uTextureMatrix [MAX_TEXTURE_UNITS]; "
					"uniform bool uUseTexMatrix  [MAX_TEXTURE_UNITS]; "
					" "
					"/* Clip Plane Uniforms */ "
					"uniform bool uClip; "
					"uniform vec4 uClipPlane; "
					"varying float varClipDist; "
					" "
					"/* Varyings */ "
					" "
					"varying vec4 varTexCoord[MAX_TEXTURE_UNITS]; "
					"varying vec4 varVertexColor; "
					"varying float eyeDist; "
					" "
					"/* shader variables */ "
					" "
					"vec3 gNormal; "
					"vec3 gWorldPos; "
					"vec4 gColor; "
					" "
					"struct material { "
					"   vec4    Ambient; "
					"   vec4    Diffuse; "
					"   vec4    Specular; "
					"   vec4    Emission; "
					"   float   Shininess; "
					"} ; "
					" "
					"material gMaterial; "
					" "
					"vec4 lightEquation(int lidx) "
					"{		 "
					"	vec4 color = vec4(0.0); "
					"	 "
					"	float att = 1.0; "
					"	vec3 lightDir; "
					"	 "
					"	 "
					"	if( uLightPosition[lidx].w == 0.0) // Directional light "
					"	{ "
					"		lightDir = -uLightPosition[lidx].xyz; "
					"	} "
					"	else "
					"	{ "
					"		lightDir = uLightPosition[lidx].xyz - inVertexPosition.xyz; "
					"		att = 1.0 / (uLightAttenuation[lidx].y * length(lightDir)); "
					"		lightDir = normalize(lightDir); "
					"		 "
					"#ifdef USE_LIGHT_CUTOFF "
					"		if(uLightCutoff[lidx] < 180.0) "
					"		{ "
					"			// compute spot factor "
					"			float spotEffect = dot(-lightDir, uLightDirection[lidx]); "
					"			if( spotEffect >= cos( radians( uLightCutoff[lidx]))) "
					"				spotEffect = pow( spotEffect, uLightExponent[lidx]); "
					"			else "
					"				spotEffect = 0.0; "
					"			att *= spotEffect; "
					"		} "
					"#endif "
					"	} "
					"	 "
					"	if(att >= 0.0 ) "
					"	{ "
					"		color += uLightAmbient[lidx] * gMaterial.Ambient; "
					"		 "
					"		//Compute cos(Light, Normal) "
					"		float NdotL = max(dot(normalize(gNormal), lightDir), 0.0); "
					"		color += NdotL * uLightDiffuse[lidx] * gMaterial.Diffuse; "
					"		 "
					"		//Compute cos(hvec, Normal) "
					"#ifdef USE_SPECULAR "
					"		vec3 hvec = normalize(lightDir + vec3(0.0, 0.0, 1.0)); "
					"		float NdotH = dot(gNormal, hvec); "
					"		if(NdotH > 0.0) "
					"		{ "
					"			color += pow(NdotH, uMaterialShininess) * uLightSpecular[lidx] * gMaterial.Specular; "
					"		} "
					"#endif "
					"		color *= att; "
					"	} "
					"	return color; "
					"} "
					" "
					"vec4 computeLighting(void) "
					"{ "
					"	vec4 color = gMaterial.Emission + gMaterial.Ambient * uAmbientColor; "
					" "
					"	for ( int i = 0 ; i < MAX_LIGHTS; ++i) "
					"	{ "
					"		if ( uUseLight[i] ) "
					"		{ "
					"			color += lightEquation(i) ; "
					"		} "
					"	} "
					"	color.a = gMaterial.Diffuse.a; "
					"	return color; "
					"} "
					" "
					"void ReplaceColorMaterial(void) "
					"{ "
					"	gMaterial.Ambient = uMaterialAmbient; "
					"	gMaterial.Diffuse = uMaterialDiffuse; "
					"	gMaterial.Emission = uMaterialEmission; "
					"	gMaterial.Specular = uMaterialSpecular; "
					"	gMaterial.Shininess = uMaterialShininess; "
					" "
					"	if(uColorMaterial == ECM_DIFFUSE) "
					"		gMaterial.Diffuse = gColor; "
					"	else if(uColorMaterial == ECM_AMBIENT) "
					"		gMaterial.Ambient = gColor; "
					"	else if(uColorMaterial == ECM_DIFFUSE_AND_AMBIENT) "
					"	{ "
					"		gMaterial.Diffuse = gColor; "
					"		gMaterial.Ambient = gColor; "
					"	}	 "
					"	else if(uColorMaterial == ECM_EMISSIVE) "
					"		gMaterial.Emission = gColor; "
					"	else if(uColorMaterial == ECM_SPECULAR) "
					"		gMaterial.Specular = gColor; "
					"} "
					" "
					"void main(void) "
					"{ "
					"	gl_Position = uMvpMatrix * inVertexPosition; "
					"	 "
					"	gWorldPos = (uWorldMatrix * inVertexPosition).xyz; "
					"	 "
					"	gColor = inVertexColor.bgra; "
					"	 "
					"	gNormal = inVertexNormal.xyz; "
					"	if(uNormalize) "
					"		gNormal = normalize(gNormal); "
					"	 "
					"	ReplaceColorMaterial(); "
					"	if(uLighting) "
					"		varVertexColor = computeLighting(); "
					"	else "
					"		varVertexColor = gColor; "
					"	 "
					"	for(int i = 0; i < MAX_TEXTURE_UNITS; ++i) "
					"		varTexCoord[i] = vec4(0.0); "
					"	 "
					"	if( uUseTexture[0]) "
					"	{ "
					"		if(uRenderMode == SphereMap || uRenderMode == Reflection2Layer) "
					"		{ "
					"			vec3 eyeDir = normalize(inVertexPosition.xyz - uEyePos); "
					"			vec3 reflection = reflect(eyeDir, gNormal); "
					"			float m = 2.0 * sqrt(reflection.x * reflection.x + "
					"								 reflection.y * reflection.y + "
					"								 (reflection.z + 1.0) * (reflection.z + 1.0)); "
					"			varTexCoord[0] = vec4((reflection.x / m + 0.5), (reflection.y / m + 0.5), 0.0, 0.0);  "
					"		} "
					"		else "
					"		{ "
					"			varTexCoord[0] = inTexCoord0; "
					"			if(uUseTexMatrix[0]) "
					"				varTexCoord[0] *= uTextureMatrix[0]; "
					"		} "
					"	} "
					"	if(uUseTexture[1]) "
					"	{ "
					"		varTexCoord[1] = inTexCoord1; "
					"		if(uUseTexMatrix[1]) "
					"			varTexCoord[1] *= uTextureMatrix[1]; "
					"	} "
					"	 "
					"	eyeDist = length(uEyePos); "
					"	 "
					"	varClipDist = uClip ? dot(gWorldPos, uClipPlane.xyz)-uClipPlane.w : 0.0; "
					"	 "
					"	varVertexColor.rgb  = clamp(varVertexColor.rgb, 0.0, 1.0); "
					"	varVertexColor.a = gColor.a; "
					"} ";
COGLES2NormalMap.fsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_LIGHTS 2 "
					" "
					"precision mediump float; "
					" "
					"uniform sampler2D texture0; "
					"uniform sampler2D texture1; "
					" "
					"varying vec4 varTexCoord; "
					"varying vec3 varLightVector[MAX_LIGHTS]; "
					"varying vec4 varLightColor[MAX_LIGHTS]; "
					" "
					"varying vec4 debug; "
					" "
					"void main(void) "
					"{ "
					"	// fetch color and normal map "
					"	vec4 normalMap = texture2D(texture1, varTexCoord.xy) *  2.0 - 1.0; "
					"	vec4 colorMap  = texture2D(texture0, varTexCoord.xy); "
					"	 "
					"	// calculate color of light 0 "
					"	vec4 color = clamp(varLightColor[0], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[0].xyz)); "
					"	 "
					"	// calculate color of light 1 "
					"	color += clamp(varLightColor[1], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[1].xyz)); "
					" "
					"	//luminance * base color "
					"	color *= colorMap; "
					"	color.a = varLightColor[0].a; "
					"	 "
					"	gl_FragColor = color; "
					"}";
COGLES2NormalMap.vsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_LIGHTS 2 "
					" "
					"attribute vec4 inVertexPosition; "
					"attribute vec4 inVertexColor; "
					"attribute vec4 inTexCoord0; "
					"attribute vec3 inVertexNormal; "
					"attribute vec3 inVertexTangent; "
					"attribute vec3 inVertexBinormal; "
					" "
					"uniform mat4 uMvpMatrix; "
					"uniform vec4 uLightPos[MAX_LIGHTS]; "
					"uniform vec4 uLightColor[MAX_LIGHTS]; "
					" "
					"varying vec4 varTexCoord; "
					"varying vec3 varLightVector[MAX_LIGHTS]; "
					"varying vec4 varLightColor[MAX_LIGHTS]; "
					" "
					"varying vec4 debug; "
					" "
					"void main(void) "
					"{ "
					"	debug = vec4(inVertexNormal, 1.0); "
					"	// transform position to clip space "
					"	gl_Position = uMvpMatrix * inVertexPosition; "
					"	 "
					"	// vertex - lightpositions "
					"	vec4 tempLightVector0 = uLightPos[0] - inVertexPosition; "
					"	vec4 tempLightVector1 = uLightPos[1] - inVertexPosition; "
					"	 "
					"	// transform the light vector 1 with U, V, W "
					"	varLightVector[0].x = dot(inVertexTangent,  tempLightVector0.xyz); "
					"	varLightVector[0].y = dot(inVertexBinormal, tempLightVector0.xyz); "
					"	varLightVector[0].z = dot(inVertexNormal,   tempLightVector0.xyz); "
					" "
					"	 "
					"	// transform the light vector 2 with U, V, W "
					"	varLightVector[1].x = dot(inVertexTangent,  tempLightVector1.xyz); "
					"	varLightVector[1].y = dot(inVertexBinormal, tempLightVector1.xyz); "
					"	varLightVector[1].z = dot(inVertexNormal,   tempLightVector1.xyz); "
					" "
					"	// calculate attenuation of light 0 "
					"	varLightColor[0].w = 0.0; "
					"	varLightColor[0].x = dot(tempLightVector0, tempLightVector0); "
					"	varLightColor[0].x *= uLightColor[0].w; "
					"	varLightColor[0] = vec4(inversesqrt(varLightColor[0].x)); "
					"	varLightColor[0] *= uLightColor[0]; "
					"	 "
					"	// normalize light vector 0 "
					"	varLightVector[0] = normalize(varLightVector[0]); "
					"	 "
					"	// calculate attenuation of light 1 "
					"	varLightColor[1].w = 0.0; "
					"	varLightColor[1].x = dot(tempLightVector1, tempLightVector1); "
					"	varLightColor[1].x *= uLightColor[1].w; "
					"	varLightColor[1] = vec4(inversesqrt(varLightColor[1].x)); "
					"	varLightColor[1] *= uLightColor[1]; "
					"	 "
					"	// normalize light vector 1 "
					"	varLightVector[1] = normalize(varLightVector[1]); "
					"	 "
					"	// move out texture coordinates and original alpha value "
					"	varTexCoord = inTexCoord0; "
					"	varLightColor[0].a = inVertexColor.a; "
					"}";
COGLES2ParallaxMap.fsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_LIGHTS 2 "
					" "
					"precision mediump float; "
					" "
					"uniform sampler2D texture0; "
					"uniform sampler2D texture1; "
					" "
					"//uniform vec4 uLightDiffuse[MAX_LIGHTS]; "
					"uniform float uHeightScale; "
					" "
					"varying vec4 varTexCoord; "
					"varying vec3 varLightVector[MAX_LIGHTS]; "
					"varying vec4 varLightColor[MAX_LIGHTS]; "
					"varying vec3 varEyeVector; "
					" "
					"varying vec4 debug; "
					" "
					"void main(void) "
					"{ "
					"	// fetch color and normal map "
					"	vec4 normalMap = texture2D(texture1, varTexCoord.xy) *  2.0 - 1.0; "
					" "
					"	// height = height * scale "
					"	normalMap *= uHeightScale; "
					"	 "
					"	// calculate new texture coord: height * eye + oldTexCoord "
					"	vec2 offset = varEyeVector.xy * normalMap.w + varTexCoord.xy; "
					" "
					"	// fetch new textures "
					"	vec4 colorMap  = texture2D(texture0, offset); "
					"	normalMap = normalize(texture2D(texture1, offset) * 2.0 - 1.0);  "
					"	 "
					"	// calculate color of light 0 "
					"	vec4 color = clamp(varLightColor[0], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[0].xyz)); "
					"	 "
					"	// calculate color of light 1 "
					"	color += clamp(varLightColor[1], 0.0, 1.0) * dot(normalMap.xyz, normalize(varLightVector[1].xyz)); "
					" "
					"	//luminance * base color "
					"	color *= colorMap; "
					"	color.a = varLightColor[0].a; "
					"	 "
					"	gl_FragColor = color; "
					"} ";
COGLES2FixedPipeline.vsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"#define MAX_TEXTURE_UNITS 4 "
					"#define MAX_LIGHTS 8 "
					" "
					"#define SphereMap        10 "
					"#define Reflection2Layer 11 "
					" "
					"const vec4 red   = vec4(1.0, 0.0, 0.0, 1.0); "
					"const vec4 green = vec4(0.0, 1.0, 0.0, 1.0); "
					"const vec4 blue  = vec4(0.0, 0.0, 1.0, 1.0); "
					"const vec4 white = vec4(1.0); "
					"const vec4 black = vec4(0.0); "
					" "
					"/* Vertex Attributes */ "
					"  "
					"attribute vec4 inVertexPosition; "
					"attribute vec4 inVertexColor; "
					"attribute vec4 inTexCoord0; "
					"attribute vec4 inTexCoord1; "
					"attribute vec3 inVertexNormal; "
					" "
					"uniform lowp int uRenderMode; "
					" "
					"/* Matrix Uniforms */ "
					" "
					"uniform mat4 uMvpMatrix; "
					"uniform mat4 uWorldMatrix; "
					" "
					"uniform bool uNormalize; "
					"uniform vec3 uEyePos; "
					" "
					"/* Light Uniforms */ "
					" "
					"uniform bool  uUseLight         [MAX_LIGHTS]; "
					"uniform vec4  uLightPosition    [MAX_LIGHTS]; "
					"uniform vec4  uLightAmbient     [MAX_LIGHTS]; "
					"uniform vec4  uLightDiffuse     [MAX_LIGHTS]; "
					"#ifdef USE_SPECULAR "
					"uniform vec4  uLightSpecular    [MAX_LIGHTS]; "
					"#endif "
					"#ifdef USE_LIGHT_CUTOFF "
					"uniform vec3  uLightDirection   [MAX_LIGHTS]; "
					"uniform float uLightCutoff      [MAX_LIGHTS]; "
					"uniform float uLightExponent    [MAX_LIGHTS]; "
					"#endif "
					"uniform vec3  uLightAttenuation [MAX_LIGHTS]; "
					"uniform vec4  uAmbientColor; "
					"uniform bool  uLighting; "
					" "
					"/* Material Uniforms */ "
					"uniform vec4  uMaterialAmbient; "
					"uniform vec4  uMaterialEmission; "
					"uniform vec4  uMaterialDiffuse; "
					"uniform vec4  uMaterialSpecular; "
					"uniform float uMaterialShininess; "
					"uniform int   uColorMaterial; "
					" "
					"#define ECM_NONE     0 "
					"#define ECM_DIFFUSE  1 "
					"#define ECM_AMBIENT  2 "
					"#define ECM_EMISSIVE 3 "
					"#define ECM_SPECULAR 4 "
					"#define ECM_DIFFUSE_AND_AMBIENT 5 "
					" "
					"/* Texture Uniforms */ "
					"uniform bool uUseTexture    [MAX_TEXTURE_UNITS]; "
					"uniform mat4 uTextureMatrix [MAX_TEXTURE_UNITS]; "
					"uniform bool uUseTexMatrix  [MAX_TEXTURE_UNITS]; "
					" "
					"/* Clip Plane Uniforms */ "
					"uniform bool uClip; "
					"uniform vec4 uClipPlane; "
					"varying float varClipDist; "
					" "
					"/* Varyings */ "
					" "
					"varying vec4 varTexCoord[MAX_TEXTURE_UNITS]; "
					"varying vec4 varVertexColor; "
					"varying float eyeDist; "
					" "
					"/* shader variables */ "
					" "
					"vec3 gNormal; "
					"vec3 gWorldPos; "
					"vec4 gColor; "
					" "
					"struct material { "
					"   vec4    Ambient; "
					"   vec4    Diffuse; "
					"   vec4    Specular; "
					"   vec4    Emission; "
					"   float   Shininess; "
					"} ; "
					" "
					"material gMaterial; "
					" "
					"vec4 lightEquation(int lidx) "
					"{		 "
					"	vec4 color = vec4(0.0); "
					"	 "
					"	float att = 1.0; "
					"	vec3 lightDir; "
					"	 "
					"	 "
					"	if( uLightPosition[lidx].w == 0.0) // Directional light "
					"	{ "
					"		lightDir = -uLightPosition[lidx].xyz; "
					"	} "
					"	else "
					"	{ "
					"		lightDir = uLightPosition[lidx].xyz - inVertexPosition.xyz; "
					"		att = 1.0 / (uLightAttenuation[lidx].y * length(lightDir)); "
					"		lightDir = normalize(lightDir); "
					"		 "
					"#ifdef USE_LIGHT_CUTOFF "
					"		if(uLightCutoff[lidx] < 180.0) "
					"		{ "
					"			// compute spot factor "
					"			float spotEffect = dot(-lightDir, uLightDirection[lidx]); "
					"			if( spotEffect >= cos( radians( uLightCutoff[lidx]))) "
					"				spotEffect = pow( spotEffect, uLightExponent[lidx]); "
					"			else "
					"				spotEffect = 0.0; "
					"			att *= spotEffect; "
					"		} "
					"#endif "
					"	} "
					"	 "
					"	if(att >= 0.0 ) "
					"	{ "
					"		color += uLightAmbient[lidx] * gMaterial.Ambient; "
					"		 "
					"		//Compute cos(Light, Normal) "
					"		float NdotL = max(dot(normalize(gNormal), lightDir), 0.0); "
					"		color += NdotL * uLightDiffuse[lidx] * gMaterial.Diffuse; "
					"		 "
					"		//Compute cos(hvec, Normal) "
					"#ifdef USE_SPECULAR "
					"		vec3 hvec = normalize(lightDir + vec3(0.0, 0.0, 1.0)); "
					"		float NdotH = dot(gNormal, hvec); "
					"		if(NdotH > 0.0) "
					"		{ "
					"			color += pow(NdotH, uMaterialShininess) * uLightSpecular[lidx] * gMaterial.Specular; "
					"		} "
					"#endif "
					"		color *= att; "
					"	} "
					"	return color; "
					"} "
					" "
					"vec4 computeLighting(void) "
					"{ "
					"	vec4 color = gMaterial.Emission + gMaterial.Ambient * uAmbientColor; "
					" "
					"	for ( int i = 0 ; i < MAX_LIGHTS; ++i) "
					"	{ "
					"		if ( uUseLight[i] ) "
					"		{ "
					"			color += lightEquation(i) ; "
					"		} "
					"	} "
					"	color.a = gMaterial.Diffuse.a; "
					"	return color; "
					"} "
					" "
					"void ReplaceColorMaterial(void) "
					"{ "
					"	gMaterial.Ambient = uMaterialAmbient; "
					"	gMaterial.Diffuse = uMaterialDiffuse; "
					"	gMaterial.Emission = uMaterialEmission; "
					"	gMaterial.Specular = uMaterialSpecular; "
					"	gMaterial.Shininess = uMaterialShininess; "
					" "
					"	if(uColorMaterial == ECM_DIFFUSE) "
					"		gMaterial.Diffuse = gColor; "
					"	else if(uColorMaterial == ECM_AMBIENT) "
					"		gMaterial.Ambient = gColor; "
					"	else if(uColorMaterial == ECM_DIFFUSE_AND_AMBIENT) "
					"	{ "
					"		gMaterial.Diffuse = gColor; "
					"		gMaterial.Ambient = gColor; "
					"	}	 "
					"	else if(uColorMaterial == ECM_EMISSIVE) "
					"		gMaterial.Emission = gColor; "
					"	else if(uColorMaterial == ECM_SPECULAR) "
					"		gMaterial.Specular = gColor; "
					"} "
					" "
					"void main(void) "
					"{ "
					"	gl_Position = uMvpMatrix * inVertexPosition; "
					"	 "
					"	gWorldPos = (uWorldMatrix * inVertexPosition).xyz; "
					"	 "
					"	gColor = inVertexColor.bgra; "
					"	 "
					"	gNormal = inVertexNormal.xyz; "
					"	if(uNormalize) "
					"		gNormal = normalize(gNormal); "
					"	 "
					"	ReplaceColorMaterial(); "
					"	if(uLighting) "
					"		varVertexColor = computeLighting(); "
					"	else "
					"		varVertexColor = gColor; "
					"	 "
					"	for(int i = 0; i < MAX_TEXTURE_UNITS; ++i) "
					"		varTexCoord[i] = vec4(0.0); "
					"	 "
					"	if( uUseTexture[0]) "
					"	{ "
					"		if(uRenderMode == SphereMap || uRenderMode == Reflection2Layer) "
					"		{ "
					"			vec3 eyeDir = normalize(inVertexPosition.xyz - uEyePos); "
					"			vec3 reflection = reflect(eyeDir, gNormal); "
					"			float m = 2.0 * sqrt(reflection.x * reflection.x + "
					"								 reflection.y * reflection.y + "
					"								 (reflection.z + 1.0) * (reflection.z + 1.0)); "
					"			varTexCoord[0] = vec4((reflection.x / m + 0.5), (reflection.y / m + 0.5), 0.0, 0.0);  "
					"		} "
					"		else "
					"		{ "
					"			varTexCoord[0] = inTexCoord0; "
					"			if(uUseTexMatrix[0]) "
					"				varTexCoord[0] *= uTextureMatrix[0]; "
					"		} "
					"	} "
					"	if(uUseTexture[1]) "
					"	{ "
					"		varTexCoord[1] = inTexCoord1; "
					"		if(uUseTexMatrix[1]) "
					"			varTexCoord[1] *= uTextureMatrix[1]; "
					"	} "
					"	 "
					"	eyeDist = length(uEyePos); "
					"	 "
					"	varClipDist = uClip ? dot(gWorldPos, uClipPlane.xyz)-uClipPlane.w : 0.0; "
					"	 "
					"	varVertexColor.rgb  = clamp(varVertexColor.rgb, 0.0, 1.0); "
					"	varVertexColor.a = gColor.a; "
					"} ";
COGLES2Renderer2D.fsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"precision mediump float; "
					" "
					"uniform bool uUseTexture; "
					"uniform sampler2D uTextureUnit; "
					"uniform bool uAlphaTest; "
					"uniform float uAlphaValue; "
					" "
					"varying vec4 varVertexColor; "
					"varying vec4 varTexCoord; "
					" "
					"void main(void) "
					"{ "
					"	vec4 color = varVertexColor; "
					"	vec4 texel = texture2D(uTextureUnit, varTexCoord.xy); "
					"	if(uUseTexture) "
					"	{ "
					"		color *= texel; "
					"	} "
					"	 "
					"	if(uAlphaTest && !(color.a > uAlphaValue)) "
					"		discard; "
					"	 "
					"	gl_FragColor = color; "
					"} ";
COGLES2Renderer2D.vsh = 

					"// Copyright (C) 2009-2010 Amundis "
					"// Heavily based on the OpenGL driver implemented by Nikolaus Gebhardt "
					"// and OpenGL ES driver implemented by Christian Stehno "
					"// This file is part of the "Irrlicht Engine". "
					"// For conditions of distribution and use, see copyright notice in Irrlicht.h "
					"attribute vec4 inVertexPosition; "
					"attribute vec4 inVertexColor; "
					"attribute vec4 inTexCoord0; "
					" "
					"uniform mat4 uOrthoMatrix; "
					" "
					"varying vec4 varVertexColor; "
					"varying vec4 varTexCoord; "
					" "
					"void main(void) "
					"{ "
					"	gl_Position    = uOrthoMatrix * inVertexPosition; "
					"	varVertexColor = inVertexColor.bgra; "
					"	varTexCoord    = inTexCoord0; "
					"} ";

}
}
}